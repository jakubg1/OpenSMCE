--!!--
-- Auto-generated by DocLang Generator
-- REMOVE THIS COMMENT IF YOU MODIFY THIS FILE
-- in order to protect it from being overwritten!
--!!--

local class = require "com.class"

---@class LevelConfig
---@overload fun(data, path, isAnonymous):LevelConfig
local LevelConfig = class:derive("LevelConfig")

LevelConfig.metadata = {
    schemaPath = "level.json"
}

---Constructs an instance of LevelConfig.
---@param data table Raw data from a file.
---@param path string? Path to the file. Used for error messages and saving data.
---@param isAnonymous boolean? If `true`, this resource is anonymous and its path is invalid for saving data.
---@param base LevelConfig? If specified, this resource extends the provided resource. Any missing fields are prepended from the base resource.
function LevelConfig:new(data, path, isAnonymous, base)
    local u = _ConfigUtils
    self._path = path
    self._alias = data._alias
    self._isAnonymous = isAnonymous

    base = base or {}

    self.map = u.parseString(data, base, path, {"map"})
    self.sequence = u.parseLevelSequenceConfig(data, base, path, {"sequence"})
    self.music = u.parseMusic(data, base, path, {"music"})
    self.dangerMusic = u.parseMusicOpt(data, base, path, {"dangerMusic"})
    self.ambientMusic = u.parseMusicOpt(data, base, path, {"ambientMusic"})
    self.dangerSound = u.parseSoundEventOpt(data, base, path, {"dangerSound"})
    self.dangerLoopSound = u.parseSoundEventOpt(data, base, path, {"dangerLoopSound"})
    self.warmupLoopSound = u.parseSoundEventOpt(data, base, path, {"warmupLoopSound"})
    self.failSound = u.parseSoundEventOpt(data, base, path, {"failSound"})
    self.failLoopSound = u.parseSoundEventOpt(data, base, path, {"failLoopSound"})
    self.colorGeneratorNormal = u.parseColorGeneratorConfig(data, base, path, {"colorGeneratorNormal"})
    self.colorGeneratorDanger = u.parseColorGeneratorConfig(data, base, path, {"colorGeneratorDanger"})

    ---@type {shooter: ShooterConfig, movement: ShooterMovementConfig?}
    if data.shooter then
        self.shooter = {}
        self.shooter.shooter = u.parseShooterConfig(data, base, path, {"shooter", "shooter"})
        self.shooter.movement = u.parseShooterMovementConfigOpt(data, base, path, {"shooter", "movement"})
    end

    self.matchEffect = u.parseSphereEffectConfig(data, base, path, {"matchEffect"})

    ---@type {type: "destroyedSpheres"|"timeElapsed"|"score"|"sphereChainsSpawned", target: number}[]
    self.objectives = {}
    for i = 1, #data.objectives do
        self.objectives[i] = {}
        ---@type "destroyedSpheres"|"timeElapsed"|"score"|"sphereChainsSpawned"
        self.objectives[i].type = u.parseString(data, base, path, {"objectives", i, "type"})
        self.objectives[i].target = u.parseNumber(data, base, path, {"objectives", i, "target"})
    end

    ---@type table<string, number>
    if data.variables then
        self.variables = {}
        for n, _ in pairs(data.variables) do
            self.variables[n] = u.parseNumber(data, base, path, {"variables", n})
        end
    end

    ---@type {trainRules: LevelTrainRulesConfig, spawnDistance: number, dangerDistance: number, dangerParticle: ParticleEffectConfig?, dangerParticleLayer: string, speeds: {distance: number?, offset: number?, offsetFromEnd: number?, speed: number, transition: table}[]}[]
    self.pathsBehavior = {}
    for i = 1, #data.pathsBehavior do
        self.pathsBehavior[i] = {}
        self.pathsBehavior[i].trainRules = u.parseLevelTrainRulesConfig(data, base, path, {"pathsBehavior", i, "trainRules"})
        self.pathsBehavior[i].spawnDistance = u.parseNumber(data, base, path, {"pathsBehavior", i, "spawnDistance"})
        self.pathsBehavior[i].dangerDistance = u.parseNumber(data, base, path, {"pathsBehavior", i, "dangerDistance"})
        self.pathsBehavior[i].dangerParticle = u.parseParticleEffectConfigOpt(data, base, path, {"pathsBehavior", i, "dangerParticle"})
        self.pathsBehavior[i].dangerParticleLayer = u.parseStringOpt(data, base, path, {"pathsBehavior", i, "dangerParticleLayer"}, "GameLevelWarningPsys")

        ---@type {distance: number?, offset: number?, offsetFromEnd: number?, speed: number, transition: table}[]
        self.pathsBehavior[i].speeds = {}
        for j = 1, #data.pathsBehavior[i].speeds do
            self.pathsBehavior[i].speeds[j] = {}
            self.pathsBehavior[i].speeds[j].distance = u.parseNumberOpt(data, base, path, {"pathsBehavior", i, "speeds", j, "distance"})
            self.pathsBehavior[i].speeds[j].offset = u.parseNumberOpt(data, base, path, {"pathsBehavior", i, "speeds", j, "offset"})
            self.pathsBehavior[i].speeds[j].offsetFromEnd = u.parseNumberOpt(data, base, path, {"pathsBehavior", i, "speeds", j, "offsetFromEnd"})
            self.pathsBehavior[i].speeds[j].speed = u.parseNumber(data, base, path, {"pathsBehavior", i, "speeds", j, "speed"})

            ---@type table
            if data.pathsBehavior[i].speeds[j].transition then
                self.pathsBehavior[i].speeds[j].transition = {}
                self.pathsBehavior[i].speeds[j].transition.type = u.parseString(data, base, path, {"pathsBehavior", i, "speeds", j, "transition", "type"})
                if self.pathsBehavior[i].speeds[j].transition.type == "instant" then
                    -- No fields
                elseif self.pathsBehavior[i].speeds[j].transition.type == "linear" then
                    -- No fields
                elseif self.pathsBehavior[i].speeds[j].transition.type == "bezier" then
                    self.pathsBehavior[i].speeds[j].transition.point1 = u.parseNumber(data, base, path, {"pathsBehavior", i, "speeds", j, "transition", "point1"})
                    self.pathsBehavior[i].speeds[j].transition.point2 = u.parseNumber(data, base, path, {"pathsBehavior", i, "speeds", j, "transition", "point2"})
                else
                    error(string.format("Unknown transition type: %s (expected \"instant\", \"linear\", \"bezier\")", self.pathsBehavior[i].speeds[j].transition.type))
                end
            end
        end
    end
end

---Injects functions to Resource Manager regarding this resource type.
---@param ResourceManager ResourceManager Resource Manager class to inject the functions to.
function LevelConfig.inject(ResourceManager)
    ---@class ResourceManager
    ResourceManager = ResourceManager

    ---Retrieves a LevelConfig by given path.
    ---@param reference string The path to the resource.
    ---@return LevelConfig
    function ResourceManager:getLevelConfig(reference)
        return self:getResourceConfig(reference, "Level")
    end
end

return LevelConfig