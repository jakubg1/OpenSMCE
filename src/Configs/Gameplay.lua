--!!--
-- Auto-generated by DocLang Generator
-- REMOVE THIS COMMENT IF YOU MODIFY THIS FILE
-- in order to protect it from being overwritten!
--!!--

local class = require "com.class"

---@class GameplayConfig
---@overload fun(data, path, isAnonymous):GameplayConfig
local GameplayConfig = class:derive("GameplayConfig")

GameplayConfig.metadata = {
    schemaPath = "config/gameplay.json"
}

---Constructs an instance of GameplayConfig.
---@param data table Raw data from a file.
---@param path string? Path to the file. Used for error messages and saving data.
---@param isAnonymous boolean? If `true`, this resource is anonymous and its path is invalid for saving data.
---@param base GameplayConfig? If specified, this resource extends the provided resource. Any missing fields are prepended from the base resource.
function GameplayConfig:new(data, path, isAnonymous, base)
    local u = _ConfigUtils
    self._path = path
    self._alias = data._alias
    self._isAnonymous = isAnonymous

    base = base or {}

    ---@type {buttonClickSound: SoundEvent?, buttonHoverSound: SoundEvent?, buttonReleaseSound: SoundEvent?}
    self.ui = {}
    self.ui.buttonClickSound = u.parseSoundEventOpt(data, base, path, {"ui", "buttonClickSound"})
    self.ui.buttonHoverSound = u.parseSoundEventOpt(data, base, path, {"ui", "buttonHoverSound"})
    self.ui.buttonReleaseSound = u.parseSoundEventOpt(data, base, path, {"ui", "buttonReleaseSound"})

    self.scoreFormat = u.parseExprStringOpt(data, base, path, {"scoreFormat"})

    ---@type {acceleration: number, attractionAcceleration: number?, attractionForwardDecceleration: number?, attractionForwardDeccelerationScarab: number?, decceleration: number, backwardsDecceleration: number?, attractionSpeedBase: number, attractionSpeedMult: number, knockbackSpeedBase: number, knockbackSpeedMult: number, knockbackTime: number?, knockbackStopAfterTime: boolean?, foulSpeed: number, foulAcceleration: number?, foulDestroySpheres: table, overspeedCheck: boolean, invincibleScarabs: boolean?, invincibleScarabFrontMatters: boolean?, luxorized: boolean?, joinSound: SoundEvent, newGroupSound: SoundEvent, noScarabs: boolean?, noScarabAttraction: boolean?, permitLongMatches: boolean, instantMatches: boolean?, cascadeScope: "chain"|"path"|"level", distanceEvents: {reference: "front"|"back", distance: number, forwards: boolean, backwards: boolean, event: GameEventConfig}[]}
    self.sphereBehavior = {}
    self.sphereBehavior.acceleration = u.parseNumber(data, base, path, {"sphereBehavior", "acceleration"})
    self.sphereBehavior.attractionAcceleration = u.parseNumberOpt(data, base, path, {"sphereBehavior", "attractionAcceleration"})
    self.sphereBehavior.attractionForwardDecceleration = u.parseNumberOpt(data, base, path, {"sphereBehavior", "attractionForwardDecceleration"})
    self.sphereBehavior.attractionForwardDeccelerationScarab = u.parseNumberOpt(data, base, path, {"sphereBehavior", "attractionForwardDeccelerationScarab"})
    self.sphereBehavior.decceleration = u.parseNumber(data, base, path, {"sphereBehavior", "decceleration"})
    self.sphereBehavior.backwardsDecceleration = u.parseNumberOpt(data, base, path, {"sphereBehavior", "backwardsDecceleration"})
    self.sphereBehavior.attractionSpeedBase = u.parseNumber(data, base, path, {"sphereBehavior", "attractionSpeedBase"})
    self.sphereBehavior.attractionSpeedMult = u.parseNumber(data, base, path, {"sphereBehavior", "attractionSpeedMult"})
    self.sphereBehavior.knockbackSpeedBase = u.parseNumber(data, base, path, {"sphereBehavior", "knockbackSpeedBase"})
    self.sphereBehavior.knockbackSpeedMult = u.parseNumber(data, base, path, {"sphereBehavior", "knockbackSpeedMult"})
    self.sphereBehavior.knockbackTime = u.parseNumberOpt(data, base, path, {"sphereBehavior", "knockbackTime"})
    self.sphereBehavior.knockbackStopAfterTime = u.parseBooleanOpt(data, base, path, {"sphereBehavior", "knockbackStopAfterTime"})
    self.sphereBehavior.foulSpeed = u.parseNumber(data, base, path, {"sphereBehavior", "foulSpeed"})
    self.sphereBehavior.foulAcceleration = u.parseNumberOpt(data, base, path, {"sphereBehavior", "foulAcceleration"})

    ---@type table
    self.sphereBehavior.foulDestroySpheres = {}
    self.sphereBehavior.foulDestroySpheres.type = u.parseString(data, base, path, {"sphereBehavior", "foulDestroySpheres", "type"})
    if self.sphereBehavior.foulDestroySpheres.type == "atEnd" then
        -- No fields
    elseif self.sphereBehavior.foulDestroySpheres.type == "fromEnd" then
        self.sphereBehavior.foulDestroySpheres.delay = u.parseNumber(data, base, path, {"sphereBehavior", "foulDestroySpheres", "delay"})
        self.sphereBehavior.foulDestroySpheres.subsequentDelay = u.parseNumber(data, base, path, {"sphereBehavior", "foulDestroySpheres", "subsequentDelay"})
    else
        error(string.format("Unknown foulDestroySpheres type: %s (expected \"atEnd\", \"fromEnd\")", self.sphereBehavior.foulDestroySpheres.type))
    end

    self.sphereBehavior.overspeedCheck = u.parseBoolean(data, base, path, {"sphereBehavior", "overspeedCheck"})
    self.sphereBehavior.invincibleScarabs = u.parseBooleanOpt(data, base, path, {"sphereBehavior", "invincibleScarabs"})
    self.sphereBehavior.invincibleScarabFrontMatters = u.parseBooleanOpt(data, base, path, {"sphereBehavior", "invincibleScarabFrontMatters"})
    self.sphereBehavior.luxorized = u.parseBooleanOpt(data, base, path, {"sphereBehavior", "luxorized"})
    self.sphereBehavior.joinSound = u.parseSoundEvent(data, base, path, {"sphereBehavior", "joinSound"})
    self.sphereBehavior.newGroupSound = u.parseSoundEvent(data, base, path, {"sphereBehavior", "newGroupSound"})
    self.sphereBehavior.noScarabs = u.parseBooleanOpt(data, base, path, {"sphereBehavior", "noScarabs"})
    self.sphereBehavior.noScarabAttraction = u.parseBooleanOpt(data, base, path, {"sphereBehavior", "noScarabAttraction"})
    self.sphereBehavior.permitLongMatches = u.parseBoolean(data, base, path, {"sphereBehavior", "permitLongMatches"})
    self.sphereBehavior.instantMatches = u.parseBooleanOpt(data, base, path, {"sphereBehavior", "instantMatches"})
    ---@type "chain"|"path"|"level"
    self.sphereBehavior.cascadeScope = u.parseStringOpt(data, base, path, {"sphereBehavior", "cascadeScope"}, "chain")

    ---@type {reference: "front"|"back", distance: number, forwards: boolean, backwards: boolean, event: GameEventConfig}[]
    self.sphereBehavior.distanceEvents = {}
    if data.sphereBehavior.distanceEvents then
        for i = 1, #data.sphereBehavior.distanceEvents do
            self.sphereBehavior.distanceEvents[i] = {}
            ---@type "front"|"back"
            self.sphereBehavior.distanceEvents[i].reference = u.parseString(data, base, path, {"sphereBehavior", "distanceEvents", i, "reference"})
            self.sphereBehavior.distanceEvents[i].distance = u.parseNumber(data, base, path, {"sphereBehavior", "distanceEvents", i, "distance"})
            self.sphereBehavior.distanceEvents[i].forwards = u.parseBooleanOpt(data, base, path, {"sphereBehavior", "distanceEvents", i, "forwards"}, false)
            self.sphereBehavior.distanceEvents[i].backwards = u.parseBooleanOpt(data, base, path, {"sphereBehavior", "distanceEvents", i, "backwards"}, false)
            self.sphereBehavior.distanceEvents[i].event = u.parseGameEventConfig(data, base, path, {"sphereBehavior", "distanceEvents", i, "event"})
        end
    end

    ---@type {particle: ParticleEffectConfig, sound: SoundEvent, posY: integer}
    if data.net then
        self.net = {}
        self.net.particle = u.parseParticleEffectConfig(data, base, path, {"net", "particle"})
        self.net.sound = u.parseSoundEvent(data, base, path, {"net", "sound"})
        self.net.posY = u.parseInteger(data, base, path, {"net", "posY"})
    end

    ---@type table<string, number>
    if data.levelVariables then
        self.levelVariables = {}
        for n, _ in pairs(data.levelVariables) do
            self.levelVariables[n] = u.parseNumber(data, base, path, {"levelVariables", n})
        end
    end

    ---@type table<string, {countDown: boolean?, value: number}>
    if data.levelTimers then
        self.levelTimers = {}
        for n, _ in pairs(data.levelTimers) do
            self.levelTimers[n] = {}
            self.levelTimers[n].countDown = u.parseBooleanOpt(data, base, path, {"levelTimers", n, "countDown"})
            self.levelTimers[n].value = u.parseNumberOpt(data, base, path, {"levelTimers", n, "value"}, 0)
        end
    end

    ---@type table<string, {}>
    if data.levelTimerSeries then
        self.levelTimerSeries = {}
        for n, _ in pairs(data.levelTimerSeries) do
            self.levelTimerSeries[n] = {}
        end
    end
end

---Injects functions to Resource Manager regarding this resource type.
---@param ResourceManager ResourceManager Resource Manager class to inject the functions to.
function GameplayConfig.inject(ResourceManager)
    ---@class ResourceManager
    ResourceManager = ResourceManager

    ---Retrieves a GameplayConfig by given path.
    ---@param reference string The path to the resource.
    ---@return GameplayConfig
    function ResourceManager:getGameplayConfig(reference)
        return self:getResourceConfig(reference, "Gameplay")
    end
end

return GameplayConfig