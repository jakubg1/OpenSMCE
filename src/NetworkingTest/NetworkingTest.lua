local Class = require("com.class")
local json = require("com.json")
local UserList = require("src.NetworkingTest.UserList")

---@class NetworkingTest : Class
---@overload fun(): NetworkingTest
local NetworkingTest = Class:derive("NetworkingTest")

-- The protocol used in this Networking Test is as follows:
-- The messages are sent in JSON format, using `json.encode()` and `json.decode()`.
-- Each packet has a `type` field and some additional fields depending on the type.
-- Here are the message types:
-- "ERR" (H->C) - Sent by the host if the client's request cannot be satisfied.
-- - message (string) - The error message.
-- "JOIN" (C->H) - Sent by the client when connecting to the host.
-- "JOIX" (H->C) - Sent by the host as a confirmation back to the client in response to their JOIN.
-- - name (string) - Client name generated by the game.
-- - ip (string) - IP address of the server.
-- - port (integer) - Port number of the server.
-- "LEAV" (C->H) - Sent by the client when disconnecting.
-- "LEAV" (H->C) - Sent by the host when disconnecting. This closes the session.
-- "PING" (C->H) - Sent by the client to confirm that this client is still connected and to calculate the ping.
-- - ping (number?) - The previously calculated ping value in seconds. Doesn't exist if this is the first ping or the calculation failed somehow.
-- "PING" (H->C) - Sent by the host to confirm that the host is still alive. This is only sent in response to the client's PING.
-- "MSG" (C->H) - Client sending a chat message.
-- - message (string) - The chat message to be displayed for the party.
-- "MSGX" (H->C) - Broadcasted by the host to all clients. Chat message.
-- - sender (string) - Name of the client who sent the message.
-- - message (string) - The chat message.
-- "NAME" (C->H) - Sent by the client as a request to change their current nickname.
-- - name (string) - The requested nickname.
-- "NAMX" (H->C) - Sent by the host as a response to the NAME request.
-- - name (string) - The requested nickname is returned back.

---Creates a Networking Test instance.
function NetworkingTest:new()
    self.socket = nil
    self.isHost = false -- `true` if we're hosting, or `false` if we're connected to a host. Value useless when `self.socket` is `nil`.
    self.name = nil -- The current name of this client, if it is connected to the server.
    self.userList = UserList() -- The user list.
    self.lastPingTime = nil -- Last ping time. `nil` if we are not waiting for a PING response.
    self.lastPing = nil -- Last ping measurement result. `nil` if no successful measurement has been made yet.
    self.pingDelay = 1 -- Every how many seconds the client should ping the server.
    self.pingTime = 0 -- Time since last ping. Counts up if we are connected as a client.
end

---Updates the Networking Test object. Pumps messages around.
---@param dt number Time delta in seconds.
function NetworkingTest:update(dt)
    self:receivePackets()
    if self.socket and not self.isHost and not self.lastPingTime then
        -- If we are a client and are not waiting for a ping response, count `self.pingDelay` seconds and make a ping.
        self.pingTime = self.pingTime + dt
        if self.pingTime >= self.pingDelay then
            -- Send a ping and start the clock.
            self.pingTime = 0
            self.lastPingTime = _GetPreciseTime()
            self:sendPacket({type = "PING", ping = self.lastPing})
        end
    end
end

---Attempts to host a networking session at the given IP and port.
---@param ip string? The IP address to open the socket on. Must be a valid IPv4 address or `"localhost"`. Defaults to localhost.
---@param port integer? The port number to open the socket on. Must be a free port. The default is `61518`.
function NetworkingTest:host(ip, port)
    if self.socket then
        self:printError("You're already connected! Disconnect with `nettest leave` first.")
        return
    end
    if not ip or ip == "localhost" then
        ip = "127.0.0.1"
    end
    port = port or 61518
    self.socket = _Network:udpHost(ip, port)
    if self.socket then
        self.isHost = true
        self.name = "Host"
        self.userList:addUser(ip, port, self.name)
        self:say(string.format("Socket opened on address %s:%s", ip, port))
    else
        self:printError("Failed to host a socket. Check if the address and the port are correct.")
    end
end

---Attempts to join a hosted networking session at the given IP and port.
---@param ip string? The IP address of the server. Must be a valid IPv4 address or `"localhost"`. Defaults to localhost.
---@param port integer? The port number the server is hosted on. The default is `61518`.
function NetworkingTest:join(ip, port)
    if self.socket then
        self:printError("You're already connected! Disconnect with `nettest leave` first.")
        return
    end
    if not ip or ip == "localhost" then
        ip = "127.0.0.1"
    end
    port = port or 61518
    self.socket = _Network:udpJoin(ip, port)
    if self.socket then
        self.isHost = false
        self:sendPacket({type = "JOIN"})
    else
        self:printError("Failed to connect to the server. Check if the address and the port are correct.")
    end
end

---Ends the current host/connection session and closes the currently open socket.
function NetworkingTest:leave()
    if not self.socket then
        self:printError("No connection is currently ongoing.")
        return
    end
    self:disconnect()
    self:say("Connection ended successfully.")
end

---Changes this client's nickname to the specified one.
---@param name string The new nickname to be used.
function NetworkingTest:setName(name)
    if not self.socket then
        self:printError("You're currently not connected. Connect with `net join` or host with `net host` first.")
        return
    end
    if self.isHost then
        local success, msg = self:validateUsername(name)
        if not success then
            self:printError(assert(msg))
            return
        end
        self.userList:renameUser(self.name, name)
        self.name = name
        self:printChatMessage("Your name has been changed to " .. self.name)
    else
        self:sendPacket({type = "NAME", name = name})
    end
end

---Sends a message to all other clients in the party.
--- - For hosts: a `MSGX` packet is sent to all connected clients.
--- - For clients: a `MSG` packet is sent to the host, which will dispatch the message to all the clients.
---@param message string The message to be sent to all clients of the party.
function NetworkingTest:send(message)
    if not self.socket then
        self:printError("You're currently not connected. Connect with `net join` or host with `net host` first.")
        return
    end
    if self.isHost then
        self:broadcastChatMessage(message, self.name)
    else
        self:sendPacket({type = "MSG", message = message})
    end
end

---Displays a list of all connected users in the party in the console.
function NetworkingTest:list()
    assert(self.isHost, "Command not available to clients for now")
    self:say("Name                 Ping   Time  IP:Port")
    local users = self.userList:getUsers()
    for i, name in ipairs(_Utils.tableGetSortedKeys(users)) do
        local user = users[name]
        self:say(string.format("%s - address: %s:%s", name, user.ip, user.port))
    end
end

---Disconnects from the party and closes the socket connection.
function NetworkingTest:disconnect()
    if not self.socket then
        return
    end
    self:sendPacket({type = "LEAV"})
    self.socket:close()
    self.socket = nil
    self.userList:empty()
    self.lastPing = nil
end

---Validates the provided username. If it is valid, returns `true`. Otherwise, returns `false` and the error message.
---@private
---@param name string The usernmae to be validated.
---@return boolean, string?
function NetworkingTest:validateUsername(name)
    if name == "" then
        return false, "Please specify a valid username."
    end
    if self.userList:getUser(name) then
        return false, "The given username already exists. Please specify a different name."
    end
    return true
end

---Broadcasts a chat message to all connected clients if you're a host.
---@private
---@param message string The message body.
---@param sender string? The nickname of the client who has sent this message.
function NetworkingTest:broadcastChatMessage(message, sender)
    assert(self.isHost, "Clients cannot broadcast messages! Are you stupid?")
    self:printChatMessage(message, sender)
    self:sendPacket({type = "MSGX", sender = sender, message = message})
end

---Formats and prints a chat message locally to the console.
---@private
---@param message string The message body.
---@param sender string? The nickname of the client who has sent this message. If `nil`, it is treated as a system message.
function NetworkingTest:printChatMessage(message, sender)
    if sender then
        self:say(string.format("[%s] %s", sender, message))
    else
        self:say(string.format(">>> %s", message), _COLORS.yellow)
    end
end

---Prints an error message locally to the console.
---@private
---@param message string The error message.
function NetworkingTest:printError(message)
    self:say(message, _COLORS.lightRed)
end

---Broadcasts or sends a packet to the designated client in this party if you're the host, or to the host if you're the client.
---@private
---@param payload table Data to be sent.
---@param ip string? IP address of the client to be delivered to. If you're the host, the data will be broadcasted if left out. If you're the client, this field is ignored.
---@param port integer? The port of the client to be delivered to. If you're the host, the data will be broadcasted if left out. If you're the client, this field is ignored.
function NetworkingTest:sendPacket(payload, ip, port)
    local data = json.encode(payload)
    if self.isHost then
        if ip and port then
            self.socket:sendto(data, ip, port)
        else
            -- Broadcast data.
            for name, user in pairs(self.userList:getUsers()) do
                self.socket:sendto(data, user.ip, user.port)
            end
        end
    else
        self.socket:send(data)
    end
end

---Receives all awaiting packets in the currently ongoing connection.
---@private
function NetworkingTest:receivePackets()
    if not self.socket then
        return
    end
    if self.isHost then
        local data, ip, port = self.socket:receivefrom()
        while data do
            print("Received: " .. data)
            self:receivePacket(json.decode(data), ip, port)
            if not self.socket then
                -- Make sure to kill the loop if we've just killed the socket as a result of handling the previous packet.
                break
            end
            -- Continue receiving packets until no more packets await in the connection.
            data, ip, port = self.socket:receivefrom()
        end
    else
        local data = self.socket:receive()
        while data do
            print("Received: " .. data)
            self:receivePacket(json.decode(data))
            if not self.socket then
                -- Make sure to kill the loop if we've just killed the socket as a result of handling the previous packet.
                break
            end
            -- Continue receiving packets until no more packets await in the connection.
            data = self.socket:receive()
        end
    end
end

---Called when a packet is received.
---@private
---@param payload table Received data.
---@param ip string? The IP address of the sender. This data is only available for the host.
---@param port integer? The port number of the sender. This data is only available for the host.
function NetworkingTest:receivePacket(payload, ip, port)
    if self.isHost then
        assert(ip and port, "Missing recv ip or port while being a host! Who coded this?!")
        -- Packets dispatched by the host.
        if payload.type == "JOIN" then
            -- A new user has joined. Generate a name for them and store the IP address and port.
            local name = self.userList:getNewUserName()
            self.userList:addUser(ip, port, name)
            self:broadcastChatMessage(name .. " joined the party!")
            self:printChatMessage(string.format("%s is connected at %s:%s", name, ip, port))
            local hostIP, hostPort = self.socket:getsockname()
            self:sendPacket({type = "JOIX", name = name, ip = hostIP, port = hostPort}, ip, port)
        elseif payload.type == "LEAV" then
            -- The user is leaving us. :(
            local name = self.userList:getUserNameFromSocket(ip, port)
            if not name then
                -- It was a random fluke. Ignore the packet.
                return
            end
            self.userList:removeUser(name)
            self:broadcastChatMessage(name .. " left the party.")
        elseif payload.type == "PING" then
            -- We've got a ping from one of the users. Respond.
            self:sendPacket({type = "PING"}, ip, port)
        elseif payload.type == "MSG" then
            -- We're told to broadcast this message from one of the users.
            local name = self.userList:getUserNameFromSocket(ip, port)
            self:broadcastChatMessage(payload.message, name)
        elseif payload.type == "NAME" then
            -- We're told to change the provided user's name.
            local success, msg = self:validateUsername(payload.name)
            if not success then
                self:sendPacket({type = "ERR", message = msg})
                return
            end
            local name = self.userList:getUserNameFromSocket(ip, port)
            if not name then
                -- It was a random fluke. Ignore the packet.
                return
            end
            self.userList:renameUser(name, payload.name)
            self:sendPacket({type = "NAMX", name = payload.name})
        end
    else
        -- Packets dispatched by the clients.
        if payload.type == "ERR" then
            -- An error.
            self:printError(payload.message)
        elseif payload.type == "JOIX" then
            -- Confirmation that we've joined and are given a username.
            self.name = payload.name
            self:printChatMessage(string.format("Successfully connected to the server at %s:%s", payload.ip, payload.port))
            self:printChatMessage("Your name is " .. self.name)
        elseif payload.type == "LEAV" then
            -- The server is leaving, which means the world ends!
            self:disconnect()
            self:printChatMessage("The host has left! Session terminated.")
        elseif payload.type == "PING" then
            -- We've got a ping back!! Calculate the ping value and store it so we can send it to the server next time.
            self.lastPing = nil
            if self.lastPingTime then
                self.lastPing = _GetPreciseTime() - self.lastPingTime
                self.lastPingTime = nil
                print(string.format("Ping: %dms", self.lastPing * 1000))
            end
        elseif payload.type == "MSGX" then
            -- Received a new message.
            self:printChatMessage(payload.message, payload.sender)
        elseif payload.type == "NAMX" then
            -- Our nickname has changed.
            self.name = payload.name
            self:printChatMessage("Your name has been changed to " .. self.name)
        end
    end
end

---Outputs a message to the ingame console and to the log.
---@private
---@param message string The message to be sent.
---@param color Color? The color of the message, white by default.
function NetworkingTest:say(message, color)
    _Debug:print({_COLORS.green, "[NetTest] ", color or _COLORS.white, message})
end

return NetworkingTest