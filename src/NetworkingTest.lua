local Class = require("com.class")
local json = require("com.json")

---@class NetworkingTest : Class
---@overload fun(): NetworkingTest
local NetworkingTest = Class:derive("NetworkingTest")

-- The protocol used in this Networking Test is as follows:
-- The messages are sent in JSON format, using `json.encode()` and `json.decode()`.
-- Each packet has a `type` field and some additional fields depending on the type.
-- Here are the message types:
-- "JOIN" (C->H) - Sent by the client when connecting to the host.
-- "JOIX" (H->C) - Sent by the host as a confirmation back to the client in response to their JOIN.
-- - name (string) - Client name generated by the game.
-- "MSG" (C->H) - Client sending a chat message.
-- - message (string) - The chat message to be displayed for the party.
-- "MSGX" (H->C) - Broadcasted by the host to all clients. Chat message.
-- - sender (string) - Name of the client who sent the message.
-- - message (string) - The chat message.

---Creates a Networking Test instance.
function NetworkingTest:new()
    self.socket = nil
    self.isHost = false -- `true` if we're hosting, or `false` if we're connected to a host. Value useless when `self.socket` is `nil`.
    self.name = nil -- The current name of this client, if it is connected to the server.
    ---@type table<string, {ip: string, port: integer, atime: number}>
    self.users = {} -- A list of connected users, keyed by names. Remains empty if this user is not a host.
    ---@type table<string, table<integer, string>>
    self.nameLookup = {} -- A lookup list, keyed first by IP addresses and then by port numbers, to get the user name.
end

---Updates the Networking Test object. Pumps messages around.
---@param dt number Time delta in seconds.
function NetworkingTest:update(dt)
    self:receivePackets()
end

---Attempts to host a networking session at the given IP and port.
---@param ip string? The IP address to open the socket on. Must be a valid IPv4 address or `"localhost"`. Defaults to localhost.
---@param port integer? The port number to open the socket on. Must be a free port. The default is `61518`.
function NetworkingTest:host(ip, port)
    if self.socket then
        self:say(string.format("You're already connected! Disconnect with `nettest leave` first.", ip, port), _COLORS.lightRed)
        return
    end
    if not ip or ip == "localhost" then
        ip = "127.0.0.1"
    end
    port = port or 61518
    self.socket = _Network:udpHost(ip, port)
    if self.socket then
        self.isHost = true
        self.name = "Host"
        self:say(string.format("Socket opened on address %s:%s", ip, port))
    else
        self:say(string.format("Failed to host a socket. Check if the address and the port are correct.", ip, port), _COLORS.lightRed)
    end
end

---Attempts to join a hosted networking session at the given IP and port.
---@param ip string? The IP address of the server. Must be a valid IPv4 address or `"localhost"`. Defaults to localhost.
---@param port integer? The port number the server is hosted on. The default is `61518`.
function NetworkingTest:join(ip, port)
    if self.socket then
        self:say(string.format("You're already connected! Disconnect with `nettest leave` first.", ip, port), _COLORS.lightRed)
        return
    end
    if not ip or ip == "localhost" then
        ip = "127.0.0.1"
    end
    port = port or 61518
    self.socket = _Network:udpJoin(ip, port)
    if self.socket then
        self.isHost = false
        self:sendPacket({type = "JOIN"})
        self:say(string.format("Successfully connected to the server at %s:%s", ip, port))
    else
        self:say(string.format("Failed to connect to the server. Check if the address and the port are correct.", ip, port), _COLORS.lightRed)
    end
end

---Ends the current host/connection session and closes the currently open socket.
function NetworkingTest:leave()
    if not self.socket then
        self:say("No connection is currently ongoing.", _COLORS.lightRed)
        return
    end
    self.socket:close()
    self:say("Connection ended successfully.")
    self.socket = nil
end

---Changes this client's nickname to the specified one.
---@param name string The new nickname to be used.
function NetworkingTest:sendName(name)
    
end

---Sends a message to all other clients in the party.
--- - For hosts: a `MSGX` packet is sent to all connected clients.
--- - For clients: a `MSG` packet is sent to the host, which will dispatch the message to all the clients.
---@param message string The message to be sent to all clients of the party.
function NetworkingTest:send(message)
    if self.isHost then
        self:broadcastChatMessage(message, self.name)
    else
        self:sendPacket({type = "MSG", message = message})
    end
end

---Displays a list of all connected users in the party in the console.
function NetworkingTest:list()
    
end

---Adds a user to the `self.users` and `self.nameLookup` lists.
---@param ip string The IP address of the connected user.
---@param port integer The port number of the connected user.
---@param name string The name of the connected user.
function NetworkingTest:addUser(ip, port, name)
    self.users[name] = {ip = ip, port = port}
    self.nameLookup[ip] = self.nameLookup[ip] or {}
    self.nameLookup[ip][port] = name
end

---Returns the name of the user connected to the provided IP and port.
---Returns `nil` if nobody is connected there.
---@param ip string The IP address of the connected user.
---@param port integer The port number of the connected user.
function NetworkingTest:getUserNameFromSocket(ip, port)
    return self.nameLookup[ip] and self.nameLookup[ip][port]
end

---Returns the first free username, starting with `"Guest1"`, `"Guest2"` and so on.
---@private
---@return string
function NetworkingTest:getNewUserName()
    local n = 1
    while self.users["Guest" .. n] do
        n = n + 1
    end
    return "Guest" .. n
end

---Broadcasts a chat message to all connected clients if you're a host.
---@private
---@param message string The message body.
---@param sender string? The nickname of the client who has sent this message.
function NetworkingTest:broadcastChatMessage(message, sender)
    assert(self.isHost, "Clients cannot broadcast messages! Are you stupid?")
    self:printChatMessage(message, sender)
    self:sendPacket({type = "MSGX", sender = sender, message = message})
end

---Formats and prints a chat message locally to the console.
---@private
---@param message string The message body.
---@param sender string? The nickname of the client who has sent this message.
function NetworkingTest:printChatMessage(message, sender)
    if sender then
        self:say(string.format("[%s] %s", sender, message))
    else
        self:say(string.format(">>> %s", message), _COLORS.orange)
    end
end

---Broadcasts or sends a packet to the designated client in this party if you're the host, or to the host if you're the client.
---@private
---@param payload table Data to be sent.
---@param ip string? IP address of the client to be delivered to. If you're the host, the data will be broadcasted if left out. If you're the client, this field is ignored.
---@param port integer? The port of the client to be delivered to. If you're the host, the data will be broadcasted if left out. If you're the client, this field is ignored.
function NetworkingTest:sendPacket(payload, ip, port)
    local data = json.encode(payload)
    if self.isHost then
        if ip and port then
            self.socket:sendto(data, ip, port)
        else
            -- Broadcast data.
            for name, user in pairs(self.users) do
                self.socket:sendto(data, user.ip, user.port)
            end
        end
    else
        self.socket:send(data)
    end
end

---Receives all awaiting packets in the currently ongoing connection.
---@private
function NetworkingTest:receivePackets()
    if not self.socket then
        return
    end
    if self.isHost then
        local data, ip, port = self.socket:receivefrom()
        while data do
            print("Received: " .. data)
            self:receivePacket(json.decode(data), ip, port)
            -- Continue receiving packets until no more packets await in the connection.
            data, ip, port = self.socket:receivefrom()
        end
    else
        local data = self.socket:receive()
        while data do
            print("Received: " .. data)
            self:receivePacket(json.decode(data))
            -- Continue receiving packets until no more packets await in the connection.
            data = self.socket:receive()
        end
    end
end

---Called when a packet is received.
---@private
---@param payload table Received data.
---@param ip string? The IP address of the sender. This data is only available for the host.
---@param port integer? The port number of the sender. This data is only available for the host.
function NetworkingTest:receivePacket(payload, ip, port)
    if self.isHost then
        assert(ip and port, "Missing recv ip or port while being a host! Who coded this?!")
        -- Packets dispatched by the host.
        if payload.type == "JOIN" then
            -- A new user has joined. Generate a name for them and store the IP address and port.
            local name = self:getNewUserName()
            self:addUser(ip, port, name)
            self:broadcastChatMessage(name .. " joined the party!")
            self:printChatMessage(string.format("%s is connected at %s:%s", name, ip, port))
            self:sendPacket({type = "JOIX", name = name}, ip, port)
        elseif payload.type == "MSG" then
            -- We're told to broadcast this message from one of the users.
            local name = self:getUserNameFromSocket(ip, port)
            self:broadcastChatMessage(payload.message, name)
        end
    else
        -- Packets dispatched by the clients.
        if payload.type == "JOIX" then
            -- Confirmation that we've joined and are given a username.
            self.name = payload.name
            self:printChatMessage("Your name is " .. self.name)
        elseif payload.type == "MSGX" then
            -- Received a new message.
            self:printChatMessage(payload.message, payload.sender)
        end
    end
end

---Outputs a message to the ingame console and to the log.
---@private
---@param message string The message to be sent.
---@param color Color? The color of the message, white by default.
function NetworkingTest:say(message, color)
    _Debug:print({_COLORS.green, "[NetTest] ", color or _COLORS.white, message})
end

return NetworkingTest